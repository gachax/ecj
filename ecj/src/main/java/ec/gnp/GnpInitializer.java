package ec.gnp;

import ec.EvolutionState;
import ec.gnp.selection.GnpSubnodeSelector;
import ec.simple.SimpleInitializer;
import ec.util.Parameter;
import ec.util.ParameterDatabase;
import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;

import java.util.*;

/**
 * The main job of the initializer is to setup the ec.vector.FloatVectorSpecies so it matches the definition of the genetic network configured in gnp.params and generated by GnpNetwork
 * It also initializes function library, reward distributor and subnode selector
 *
 * @author Gatis Birkens
 */
public class GnpInitializer extends SimpleInitializer {

    private GnpFunctionLibrary functionLibrary;
    private GnpRewardDistributor rewardDistributor;
    private GnpSubnodeSelector subnodeSelector;
    //parameters read from the properties file
    private int maxTime = 0;
    private int judgementTime = Integer.MAX_VALUE;
    private int processingTime = Integer.MAX_VALUE;
    private int judgementNodeCount = 0;
    private int processingNodeCount = 0;
    private int maxSubnodeCount = 0;
    private int maxSubnodeCountMultiplyer = 0;
    private boolean startWithJudgement = false;
    private int nodeCount = 0;
    private int totalSubnodeParametersGeneCount = 0;
    private int totalNodeGeneCount = 0;
    private int totalSubnodesGeneCount = 0;
    private int subnodeParemetersCount = 0;
    private int subnodeParemetersCountMultiplyer = 0;
    private int judgementFunctionCount = 0;
    private int processingFunctionCount = 0;
    private int maxBranchCount = 0;
    private int maxBranchCountMultiplyer = 0;
    private boolean storeAllExecPaths;

    //All custom subnode parameter genes
    private Map<GnpGeneDescriptor, Object> subnodeParameterGeneDescriptors = new LinkedHashMap<>();

    //Gene maps - linking the genes in the genome array to the GnpNetworkElement, so the GnpNetworkElement objects (GnpNode, GnpSubnode, GnpBranch) can access their genes, used to generate the network in GnpNetwork
    //Map<(id of the object), int[(start gene index),(gene count)]>
    private Int2ObjectOpenHashMap<int[]> nodeGeneMap = new Int2ObjectOpenHashMap<>();
    private Int2ObjectOpenHashMap<int[]> subnodeGeneMap = new Int2ObjectOpenHashMap <>();
    private Int2ObjectOpenHashMap<int[]> subnodeParamsGeneMap = new Int2ObjectOpenHashMap <>();
    private Int2ObjectOpenHashMap<int[]> branchesGeneMap = new Int2ObjectOpenHashMap <>();

    //The count of the genes at node level. One gene, which holds the information about the count of the subnodes.
    private static final int NODE_GENE_COUNT = 1;
    //The count of the genes at subnode level. Two genes, one holds the id of the judgement function, another the id of the processing function. The relevant gene is used based on the type of the node.
    private static final int SUBNODE_GENE_COUNT = 2;
    //The count of the genes at branch level. Holds the information about the linked node.
    private static final int BRANCH_GENE_COUNT = 1;

    //Parameter names
    private static final String P_MAX_TIME = "maxTime";
    private static final String P_JUDGEMENT_TIME = "judgementTime";
    private static final String P_PROCESSING_TIME = "processingTime";
    private static final String P_JUDGEMENT_NODE_COUNT = "judgementNodeCount";
    private static final String P_PROCESSING_NODE_COUNT = "processingNodeCount";
    private static final String P_MAX_SUBNODE_COUNT = "maxSubnodeCount";
    private static final String P_START_WITH_JUDGEMENT = "startWithJudgement";
    private static final String P_SUBNODE_PARAMETERS = "subnodeParameters";
    private static final String P_COUNT = "count";
    private static final String P_SUBNODE_COUNT_SEGMENT = "subnodeCountSegment";
    private static final String P_FUNCTION_ID_SEGMENT = "subnodeFunctionIdSegment";
    private static final String P_CONNECTIONS_SEGMENT = "connectionsSegment";
    public static final String P_MIN_GENE = "min-gene";
    public static final String P_MAX_GENE = "max-gene";
    public static final String P_JUDGEMENT_FUNCTION = "judgementFunction";
    public static final String P_PROCESSING_FUNCTION = "processingFunction";
    private static final String P_REWARD_DISTRIBUTOR = "rewardDistributor";
    private static final String P_SUBNODE_SELECTION = "subnodeSelection";
    private static final String P_STORE_ALL_EXEC_PATHS = "storeAllExecPaths";

    private static final String P_VECTOR_SPECIES_SEGMENT = "vector.species.segment";
    //properties of the segments of the node, subnode and branch genes. They are set up in properties file:
    //gnp.subnodeCountSegment
    //gnp.subnodeFunctionIdSegment
    //gnp.connectionsSegment
    private Object2ObjectOpenHashMap<String, String> subnodeCountSegmentProperties = new Object2ObjectOpenHashMap<>();
    private Object2ObjectOpenHashMap<String, String> judgementFunctionIdSegmentProperties = new Object2ObjectOpenHashMap<>();
    private Object2ObjectOpenHashMap<String, String> processingFunctionIdSegmentProperties = new Object2ObjectOpenHashMap<>();
    private Object2ObjectOpenHashMap<String, String> connectionsSegmentProperites = new Object2ObjectOpenHashMap<>();

    //object templates
    private GnpNode gnpNodeTemplate;
    private GnpSubnode gnpSubnodeTemplate;
    private List<GnpSubnodeParameter> gnpSubnodeParameterTemplates;

    public Parameter defaultBase()
    {
        return GnpDefaults.base();
    }

    @Override
    public void setup(final EvolutionState state, final Parameter base) {

        super.setup(state, base);

        Parameter defaultBase = defaultBase();

        Parameter subnodeParametersParameter = defaultBase.push(P_SUBNODE_PARAMETERS);

        //load parameters
        maxTime = state.parameters.getInt(defaultBase.push(P_MAX_TIME), null);
        judgementTime = state.parameters.getInt(defaultBase.push(P_JUDGEMENT_TIME), null);
        processingTime = state.parameters.getInt(defaultBase.push(P_PROCESSING_TIME), null);
        judgementNodeCount = state.parameters.getInt(defaultBase.push(P_JUDGEMENT_NODE_COUNT), null);
        processingNodeCount = state.parameters.getInt(defaultBase.push(P_PROCESSING_NODE_COUNT), null);
        maxSubnodeCount = state.parameters.getInt(defaultBase.push(P_MAX_SUBNODE_COUNT), null);
        maxSubnodeCountMultiplyer = getMultiplyer(maxSubnodeCount);
        startWithJudgement = state.parameters.getBoolean(defaultBase.push(P_START_WITH_JUDGEMENT), null, false);
        subnodeParemetersCount = state.parameters.getInt(subnodeParametersParameter.push(P_COUNT), null);
        subnodeParemetersCountMultiplyer = getMultiplyer(subnodeParemetersCount);
        judgementFunctionCount = state.parameters.getInt(defaultBase.push(P_JUDGEMENT_FUNCTION).push(P_COUNT), null);
        processingFunctionCount = state.parameters.getInt(defaultBase.push(P_PROCESSING_FUNCTION).push(P_COUNT), null);
        storeAllExecPaths = state.parameters.getBoolean(defaultBase.push(P_STORE_ALL_EXEC_PATHS), null,false);

        //total count of the nodes
        nodeCount = judgementNodeCount + processingNodeCount;

        //setup the function library
        functionLibrary = new GnpFunctionLibrary();
        functionLibrary.setup(state, defaultBase);

        //init the reward distributor
        rewardDistributor = (GnpRewardDistributor) state.parameters.getInstanceForParameter(defaultBase.push(P_REWARD_DISTRIBUTOR), null, GnpRewardDistributor.class);
        rewardDistributor.setup(state, defaultBase.push(P_REWARD_DISTRIBUTOR));

        //init node selector
        subnodeSelector = (GnpSubnodeSelector) state.parameters.getInstanceForParameter(defaultBase.push(P_SUBNODE_SELECTION), null, GnpSubnodeSelector.class);
        subnodeSelector.setup(state, defaultBase.push(P_SUBNODE_SELECTION));

        //Get all subnode parameter gene descriptors
        for (int i = 0; i < subnodeParemetersCount; i++) {

            GnpSubnodeParameter subnodeParameter = (GnpSubnodeParameter) state.parameters.getInstanceForParameter(subnodeParametersParameter.push(String.valueOf(i)), null, GnpSubnodeParameter.class);
            subnodeParameter.setState(state);
            subnodeParameter.setupGenes();

            for (Map.Entry<GnpGeneDescriptor, Integer> geneOrder: subnodeParameter.getGenes().entrySet()) {
                subnodeParameterGeneDescriptors.put(geneOrder.getKey(), subnodeParameter);
            }

        }
        //gene lengths
        maxBranchCount = maxSubnodeCount * functionLibrary.getMaxJudgementResultCount();
        maxBranchCountMultiplyer = getMultiplyer(maxBranchCount);
        totalSubnodeParametersGeneCount = subnodeParameterGeneDescriptors.size();
        totalNodeGeneCount = NODE_GENE_COUNT + (SUBNODE_GENE_COUNT * maxSubnodeCount) + (maxSubnodeCount * totalSubnodeParametersGeneCount) + maxBranchCount;
        totalSubnodesGeneCount = (SUBNODE_GENE_COUNT + totalSubnodeParametersGeneCount) * maxSubnodeCount;

        //get segment mutation and other properties
        setAdditionalSegmentProperties(state.parameters, 0);

        //set segment boundries
        subnodeCountSegmentProperties.put(P_MIN_GENE, "1");
        subnodeCountSegmentProperties.put(P_MAX_GENE, String.valueOf(maxSubnodeCount));
        judgementFunctionIdSegmentProperties.put(P_MIN_GENE, "0");
        judgementFunctionIdSegmentProperties.put(P_MAX_GENE, String.valueOf(judgementFunctionCount-1));
        processingFunctionIdSegmentProperties.put(P_MIN_GENE, "0");
        processingFunctionIdSegmentProperties.put(P_MAX_GENE, String.valueOf(processingFunctionCount-1));
        connectionsSegmentProperites.put(P_MIN_GENE, "0");
        connectionsSegmentProperites.put(P_MAX_GENE, String.valueOf(nodeCount-1));

        setupSegments(state);
        setupGeneMap();
        setupObjectTemplates(state, subnodeParametersParameter);

    }

    //objects which are being created a lot during the evo are created as templates to be light cloned afterwards
    private void setupObjectTemplates(final EvolutionState state, Parameter subnodeParametersParameter) {

        gnpNodeTemplate = (GnpNode) state.parameters.getInstanceForParameter(defaultBase().push(GnpNode.P_NODE), null, GnpNetworkElement.class);
        gnpSubnodeTemplate =  (GnpSubnode) state.parameters.getInstanceForParameter(defaultBase().push(GnpSubnode.P_SUB_NODE), null, GnpNetworkElement.class);

        gnpSubnodeParameterTemplates= new ArrayList<>();
        for (int i = 0; i < subnodeParemetersCount; i++) {
            gnpSubnodeParameterTemplates.add((GnpSubnodeParameter) state.parameters.getInstanceForParameter(subnodeParametersParameter.push(String.valueOf(i)), null, GnpSubnodeParameter.class));
        }

    }

    //Should be some easier way to do this, for example by implementing some method in ParameterDatabase to get parameters based on the names which start with some string
    //currently it's looping through all the parameter files to find the properties for the segments needed
    private void setAdditionalSegmentProperties(ParameterDatabase parameters, int x) {

        ParameterDatabase params = parameters;

        for (int i = x; i < parameters.getParents().size(); i++) {
            params = ((ParameterDatabase) parameters.getParents().elementAt(i));
            setAdditionalSegmentProperties(params, i);
        }

        for (Enumeration<?> e = params.getProperties().propertyNames(); e.hasMoreElements(); ) {

            String name = (String) e.nextElement();
            String value = params.getProperties().getProperty(name);

            String startString = GnpDefaults.P_GNP + "." + P_SUBNODE_COUNT_SEGMENT;
            if (name.startsWith(startString)) {
                subnodeCountSegmentProperties.put(name.substring(startString.length() + 1), value);
            }
            startString = GnpDefaults.P_GNP + "." + P_FUNCTION_ID_SEGMENT;
            if (name.startsWith(startString)) {
                judgementFunctionIdSegmentProperties.put(name.substring(startString.length() + 1), value);
                processingFunctionIdSegmentProperties.put(name.substring(startString.length() + 1), value);
            }
            startString = GnpDefaults.P_GNP + "." + P_CONNECTIONS_SEGMENT;
            if (name.startsWith(startString)) {
                connectionsSegmentProperites.put(name.substring(startString.length() + 1), value);
            }

        }

    }

    public int getSubnodeParamsGeneMapKey(int nodeId, int subnodeId, int parameterId) {
        return ((nodeId + 1) * maxSubnodeCountMultiplyer * subnodeParemetersCountMultiplyer) + ((subnodeId + 1) * subnodeParemetersCountMultiplyer)  + (parameterId + 1);
    }

    public GnpSubnodeParamsGeneMapKeyParsed parseSubnodeParamsGeneMapKey(int key) {

        int nodeId = key/(maxSubnodeCountMultiplyer * subnodeParemetersCountMultiplyer) - 1;
        int parameterId = key%(subnodeParemetersCountMultiplyer) - 1;
        int subnodeId = (key - ((nodeId + 1) * maxSubnodeCountMultiplyer * subnodeParemetersCountMultiplyer) - (parameterId + 1))/subnodeParemetersCountMultiplyer - 1;

        return new GnpSubnodeParamsGeneMapKeyParsed(nodeId, subnodeId, parameterId);
    }

    public int getSubnodeGeneMapKey(int nodeId, int subnodeId) {
        return ((nodeId + 1) * maxSubnodeCountMultiplyer) + (subnodeId + 1);
    }

    public GnpSubnodeGeneMapKeyParsed parseSubnodeGeneMapKey(int key) {
        return new GnpSubnodeGeneMapKeyParsed(key/maxSubnodeCountMultiplyer - 1, key%maxSubnodeCountMultiplyer - 1);
    }

    public int getBranchGeneMapKey(int nodeId, int branchId) {
        return ((nodeId + 1) * maxBranchCountMultiplyer) + (branchId + 1);
    }

    public GnpBranchGeneMapKeyParsed parseBranchGeneMapKey(int key) {
        return new GnpBranchGeneMapKeyParsed(key/maxBranchCountMultiplyer - 1, key%maxBranchCountMultiplyer - 1);
    }

    public int getMultiplyer(int number) {

        if (number < 100000) {
            if (number < 100) {
                if (number < 10) {
                    return 10;
                } else {
                    return 100;
                }
            } else {
                if (number < 1000) {
                    return 1000;
                } else {
                    if (number < 10000) {
                        return 10000;
                    } else {
                        return 100000;
                    }
                }
            }
        } else {
            if (number < 10000000) {
                if (number < 1000000) {
                    return 1000000;
                } else {
                    return 10000000;
                }
            } else {
                if (number < 100000000) {
                    return 100000000;
                } else {
                    if (number < 1000000000) {
                        return 1000000000;
                    } else {
                        return Integer.parseInt(String.format("%-" + (int) (Math.log10(number) + 2) + "s", "1").replace(' ', '0'));
                    }
                }
            }
        }

    }

    //Gene map contains the unique id of the network element, start gene within the genome and number of genes taken
    //Gene mapas are used to generate GnpNetwork
    private void setupGeneMap() {

        for (int n = 0; n < nodeCount; n++) {

            int offset = n + (n * (totalNodeGeneCount-1));

            nodeGeneMap.put(n, new int[] {offset, NODE_GENE_COUNT});

            for (int sub = 0; sub < maxSubnodeCount; sub++) {

                offset = NODE_GENE_COUNT + (sub * (SUBNODE_GENE_COUNT + totalSubnodeParametersGeneCount)) + (n * totalNodeGeneCount);

                subnodeGeneMap.put(getSubnodeGeneMapKey(n, sub), new int[]{offset, SUBNODE_GENE_COUNT});

                String prevSubnodeParameterClassName = null;
                int totalSubnodeParametersGeneCountSoFar = 0;
                int subnodeParameterCount = 0;
                for (Map.Entry<GnpGeneDescriptor, Object> entry : subnodeParameterGeneDescriptors.entrySet()) {

                    Object subnodeParameter = entry.getValue();

                    if (!subnodeParameter.getClass().getName().equals(prevSubnodeParameterClassName)) {

                        subnodeParamsGeneMap.put(getSubnodeParamsGeneMapKey(n, sub, subnodeParameterCount), new int[]{totalSubnodeParametersGeneCountSoFar + SUBNODE_GENE_COUNT + offset, ((GnpSubnodeParameter)subnodeParameter).getGenes().size()});

                        totalSubnodeParametersGeneCountSoFar += ((GnpSubnodeParameter)subnodeParameter).getGenes().size();
                        subnodeParameterCount++;

                    }

                    prevSubnodeParameterClassName = subnodeParameter.getClass().getName();

                }

            }

            for (int b = 0; b < maxBranchCount; b++ ) {
                offset = 1 + b + totalSubnodesGeneCount + (n * totalNodeGeneCount);
                branchesGeneMap.put(getBranchGeneMapKey(n, b), new int[]{offset, BRANCH_GENE_COUNT});
            }

        }

    }

    /**
     * segments (gene ranges within a genome array with common boundaries and mutation parameters) are generated based on the setup of gene parameters in the properties file (for example, subnodeCountSegmentProperties)
     * and custom definition of subnode parameter genes (subnodeParameterGeneDescriptors)
     * @param state EvolutionState
     */
    private void setupSegments(final EvolutionState state) {

        int totalGeneCount = totalNodeGeneCount * nodeCount;

        //genome size
        state.parameters.set(new Parameter("vector.species.genome-size"), String.valueOf(totalGeneCount));

        //Setup the segments
        int segmentStart = 0;
        int s = 0;
        for (int n = 0; n < nodeCount; n++) {

            //gene of the node - subnode count
            segmentStart = n + (n * (totalNodeGeneCount-1));
            s = addSegment(state, segmentStart, s, subnodeCountSegmentProperties);

                for (int sub = 0; sub < maxSubnodeCount; sub++) {

                    int offset = (sub * (SUBNODE_GENE_COUNT + totalSubnodeParametersGeneCount)) + (n * totalNodeGeneCount);

                    //subnode's first segment/gene - judgement function ID
                    segmentStart = 1 + offset;
                    s = addSegment(state, segmentStart, s, judgementFunctionIdSegmentProperties);

                    //subnode's first segment/gene - processing function ID
                    segmentStart = 2 + offset;
                    s = addSegment(state, segmentStart, s, processingFunctionIdSegmentProperties);

                    //when gene description change, then new segment
                    GnpGeneDescriptor prevDesc = null;
                    int geneDsc = 1;
                    for (Map.Entry<GnpGeneDescriptor, Object> entry : subnodeParameterGeneDescriptors.entrySet()) {

                        GnpGeneDescriptor desc = entry.getKey();
                        
                        if (!desc.equal(prevDesc)) {
                            segmentStart = geneDsc + SUBNODE_GENE_COUNT + offset;
                            s = addSegment(state, segmentStart, s, desc);
                        }

                        prevDesc = desc;

                        geneDsc++;

                    }

                }

            segmentStart = 1 + totalSubnodesGeneCount + (n * totalNodeGeneCount);
            s = addSegment(state, segmentStart, s, connectionsSegmentProperites);

        }

        state.parameters.set(new Parameter("vector.species.num-segments"), String.valueOf(s));
        state.parameters.set(new Parameter("vector.species.chunk-size"), String.valueOf(totalNodeGeneCount));

        //Will be overwritten by the per-segment values
        state.parameters.set(new Parameter("vector.species.max-gene"), String.valueOf(Integer.MAX_VALUE));
        state.parameters.set(new Parameter("vector.species.min-gene"), String.valueOf(Integer.MIN_VALUE));

    }

    private int addSegment(final EvolutionState state, int segmentStart, int s, Map<String, String> segmentProperties) {

        for (Map.Entry<String, String> prop : segmentProperties.entrySet()){
            state.parameters.set(new Parameter(P_VECTOR_SPECIES_SEGMENT).push(String.valueOf(s)).push(prop.getKey()), String.valueOf(prop.getValue()));
        }

        addSegment(state, segmentStart, s);

        s++;
        return s;

    }

    private int addSegment(final EvolutionState state, int segmentStart, int s, GnpGeneDescriptor desc) {

        for (Map.Entry<String, String> param : desc.getParameters().entrySet()){
            state.parameters.set(new Parameter(P_VECTOR_SPECIES_SEGMENT).push(String.valueOf(s)).push(param.getKey()), String.valueOf(param.getValue()));
        }

        addSegment(state, segmentStart, s);

        s++;
        return s;

    }

    private void addSegment(EvolutionState state, int segmentStart, int s) {
        state.parameters.set(new Parameter(P_VECTOR_SPECIES_SEGMENT).push(String.valueOf(s)).push("start"), String.valueOf(segmentStart));
    }

    public GnpNode newGnpNodeInstance() {

        return (GnpNode) gnpNodeTemplate.lightClone();
    }

    public GnpSubnode newGnpSubnodeInstance() {

        return (GnpSubnode) gnpSubnodeTemplate.lightClone();

    }

    public GnpSubnodeParameter newGnpSubnodeParameterInstance(int id) {

        return (GnpSubnodeParameter) gnpSubnodeParameterTemplates.get(id).lightClone();

    }

    public GnpFunctionLibrary getFunctionLibrary() {
        return functionLibrary;
    }

    int getMaxTime() {
        return maxTime;
    }

    int getJudgementTime() {
        return judgementTime;
    }

    int getProcessingTime() {
        return processingTime;
    }

    int getJudgementNodeCount() {
        return judgementNodeCount;
    }

    public int getProcessingNodeCount() {
        return processingNodeCount;
    }

    public int getMaxSubnodeCount() {
        return maxSubnodeCount;
    }

    public Int2ObjectOpenHashMap<int[]> getSubnodeGeneMap() {
        return subnodeGeneMap;
    }

    public Int2ObjectOpenHashMap<int[]> getSubnodeParamsGeneMap() {
        return subnodeParamsGeneMap;
    }

    public Int2ObjectOpenHashMap<int[]> getBranchesGeneMap() {
        return branchesGeneMap;
    }

    int getNodeCount() {
        return nodeCount;
    }

    public Int2ObjectOpenHashMap<int[]> getNodeGeneMap() {
        return nodeGeneMap;
    }

    int getJudgementFunctionCount() {
        return judgementFunctionCount;
    }

    int getProcessingFunctionCount() {
        return processingFunctionCount;
    }

    public int getMaxBranchCount() {
        return maxBranchCount;
    }

    public GnpRewardDistributor getRewardDistributor() {
        return rewardDistributor;
    }

    public GnpSubnodeSelector getSubnodeSelector() {
        return subnodeSelector;
    }

    public Map<String, String> getConnectionsSegmentProperites() {
        return connectionsSegmentProperites;
    }

    public boolean isStoreAllExecPaths() {
        return storeAllExecPaths;
    }

    public boolean isStartWithJudgement() {
        return startWithJudgement;
    }

    public int getTotalSubnodeParametersGeneCount() {
        return totalSubnodeParametersGeneCount;
    }

    public int getSubnodeParemetersCount() {
        return subnodeParemetersCount;
    }
}
